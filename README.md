# `Tulips`

Welcome to your new `Tulips` project and to the Internet Computer development community. By default, creating a new project adds this README and some template files to your project directory. You can edit these template files to customize your project and to include your own code to speed up the development cycle.

To get started, you might want to explore the project directory structure and the default configuration file. Working with this project in your development environment will not affect any production deployment or identity tokens.

To learn more before you start working with `Tulips`, see the following documentation available online:

- [Quick Start](https://internetcomputer.org/docs/current/developer-docs/setup/deploy-locally)
- [SDK Developer Tools](https://internetcomputer.org/docs/current/developer-docs/setup/install)
- [Motoko Programming Language Guide](https://internetcomputer.org/docs/current/motoko/main/motoko)
- [Motoko Language Quick Reference](https://internetcomputer.org/docs/current/motoko/main/language-manual)

If you want to start working on your project right away, you might want to try the following commands:

```bash
cd Tulips/
dfx help
dfx canister --help
```

## Running the project locally

If you want to test your project locally, you can use the following commands:

```bash
# Starts the replica, running in the background
dfx start --background

# Deploys your canisters to the replica and generates your candid interface
dfx deploy
```

Once the job completes, your application will be available at `http://localhost:4943?canisterId={asset_canister_id}`.

If you have made changes to your backend canister, you can generate a new candid interface with

```bash
npm run generate
```

at any time. This is recommended before starting the frontend development server, and will be run automatically any time you run `dfx deploy`.

If you are making frontend changes, you can start a development server with

```bash
npm start
```

Which will start a server at `http://localhost:8080`, proxying API requests to the replica at port 4943.

### Note on frontend environment variables

If you are hosting frontend code somewhere without using DFX, you may need to make one of the following adjustments to ensure your project does not fetch the root key in production:

- set`DFX_NETWORK` to `ic` if you are using Webpack
- use your own preferred method to replace `process.env.DFX_NETWORK` in the autogenerated declarations
  - Setting `canisters -> {asset_canister_id} -> declarations -> env_override to a string` in `dfx.json` will replace `process.env.DFX_NETWORK` with the string in the autogenerated declarations
- Write your own `createActor` constructor

-----------------------------------------------------------------------------------------------------------

It asks two canisters in arguments: 

In another terminal, Run these two commands:

1.  dfx canister id dbank  -> You will get a principal id that will be the first argument
2.  dfx canister id nft    -> This will give the second argument


------------------------------------------------------------------------------------------------------------


1. Bank - User can check its own balance, request payout(initial amount of 1000 to be given to the user while opening the account and transfer the tokens to the other users)

2. NFT Marketplace - User can mint NFT, auction NFT and bid on the auctioned NFTs, along with that the currently owned NFT's will be visible to the user

There are three points in this project:

i. User who performs activities 

ii. Bank (It is the main backend cannister which stores all the functions and properties with which user interacts)

Here are the properties and methods of the bank:

Name of token - DAMN Tokens

Symbol of token - DAMN

Initial supply - 1000000000000

List of accounts

List of users who have claimed the payout

Check balance function 

Transfer Token Function

List of Balances function

Freeze certain amount of the user - explained further in the extended rules

Release the freeze amount -  explained further in the extended rules

List of NFT's

Map of NFT's with the current owner

List of biddings

Mint new NFT
Get Owned NFT's
Show bid NFTs to the users - their own NFTs as well but as disabled cards
get NFT data
Map of timings of the bid NFTs
Transfer ownership when timer runs out
Ping the users on transfer
iii. NFT - This is the cannister that holds the data of NFTs
Here are the functions and properties inside the NFT actor class
NFT Name
NFT owner name
IPFS image URL
Cannister Id
Transfer Ownership
Current Price
Bid status
Time stamp of Bid
Bid timer - reflected on frontend as well
Transfer Ownership - triggered immediately once the timer hits 24 hrs
Base price
Max price
set bids
set purchaser(only if amount > base price)
sell bid (change bid)


Extended rules - 
1. Whenever new account gets created, the payout option should be made available ... which was there in the last DBank app as well -- Done

2. The transfer fees is 3% of the total transaction amount        -------------------------------------------------------------------- Done

3. The minting fees is randomly between 40-60% of the desired current amount

4. The base price will be less than 220% of the current price

5. On the sale of NFT 5% of the profit will be transferred to the bank

6. Bank should have a function to distribute a certain desired amount to all the registered user. This function will not be reflected on frontend

7. Whenever user makes a bid on any NFT, the amount he/she has bid will be freezed on his/her account i.e. his/her balance should not go bellow the freeze amount. Same user can have multiple bids.

8. Whenever transfer happens it releases the bid and that amount will be transferred to the seller.

9. If someone else makes a higher bid the freeze will be released to the current user and new user's account will be made a freeze.

10. In the frontend the bid amount can be increased with at least the 5% of current bid. This should be ensured in the frontend first but also on the backend for cross verification once it passes the frontend.

============================================================================================================================================================================================================================================================================================

prompt 1
I want these things to be implemented...
1. In the starting the bank should have total supply of 1000000000000 DAMN
2. These functions and properties should be there in the code
    import Debug "mo:base/Debug";
    import Principal "mo:base/Principal";
    import Result "mo:base/Result";
    import Blob "mo:base/Blob";
    import HashMap "mo:base/HashMap";
    import Iter "mo:base/Iter";
    import Nat8 "mo:base/Nat8";
    import Array "mo:base/Array";

    // ICRC-1 Token Canister with dynamic 3% fee, one-time payout, and debugBalances
    actor class ICRC1Token() = this {
      // --- Types ---
      type Timestamp = Nat64;
      type Subaccount = Blob;
      public type Account = { owner: Principal; subaccount: ?Subaccount };
      public type TransferArgs = {
        from_subaccount: ?Subaccount;
        to: Account;
        amount: Nat;
        fee: ?Nat;           // Optional override not supported
        memo: ?Blob;
        created_at_time: ?Timestamp;
      };
      public type TransferError = {
        #BadFee: { expected_fee: Nat };
        #InsufficientFunds: { balance: Nat };
        #GenericError: { error_code: Nat; message: Text };
        #TooOld;
        #CreatedInFuture: { ledger_time: Timestamp };
        #Duplicate: { duplicate_of: Nat };
        #TemporarilyUnavailable;
        #BadBurn: { min_burn_amount: Nat };
      };
      public type Value = {
        #Nat: Nat;
        #Int: Int;
        #Text: Text;
        #Blob: Blob;
      };
      public type Result<Ok, Err> = Result.Result<Ok, Err>;

      // --- Metadata & State ---
      let NAME = "DAMN Token";
      let SYMBOL = "DAMN";
      let DECIMALS: Nat8 = 8;
      let INITIAL_SUPPLY: Nat = 1_000_000_000_000;
      let deployer: Principal = Principal.fromActor(this);

      stable var stableBalances: [((Account, Nat))] = [];
      var balances = HashMap.HashMap<Account, Nat>(
        64,
        func(a, b) = a.owner == b.owner and a.subaccount == b.subaccount,
        func(a) = Principal.hash(a.owner)
      );

      stable var stableClaims: [(Principal, Bool)] = [];
      var claimed = HashMap.HashMap<Principal, Bool>(
        128, Principal.equal, Principal.hash
      );

      // --- Upgrade Hooks ---
      system func preupgrade() {
        stableBalances := Iter.toArray(balances.entries());
        stableClaims := Iter.toArray(claimed.entries());
      };
      system func postupgrade() {
        balances := HashMap.fromIter<Account, Nat>(
          stableBalances.vals(),
          64,
          func(a, b) = a.owner == b.owner and a.subaccount == b.subaccount,
          func(a) = Principal.hash(a.owner)
        );
        claimed := HashMap.HashMap<Principal, Bool>(
          128, Principal.equal, Principal.hash
        );
        let len = Array.size(stableClaims);
        if(len > 0) {
          for (i in Iter.range(0, len - 1)) {
            let (p, b) = stableClaims[i];
            claimed.put(p, b);
          };
        };
      };

      // --- Constructor Mint ---
      balances.put({ owner = deployer; subaccount = null }, INITIAL_SUPPLY);

      // --- ICRC-1 Standard Queries ---
      public shared query func icrc1_name() : async Text { NAME };
      public shared query func icrc1_symbol() : async Text { SYMBOL };
      public shared query func icrc1_decimals() : async Nat8 { DECIMALS };
      public shared query func icrc1_fee() : async Nat { 0 };
      public shared query func icrc1_total_supply() : async Nat {
        var sum: Nat = 0;
        for ((_, bal) in balances.entries()) { sum += bal };
        sum
      };
      public shared query func icrc1_minting_account() : async ?Account {
        ?{ owner = deployer; subaccount = null }
      };
      public shared query func icrc1_balance_of(account: Account) : async Nat {
        switch (balances.get(account)) {
          case null { 0 };
          case (?b) { b };
        }
      };
      public shared query func icrc1_metadata() : async [(Text, Value)] {
        [
          ("icrc1:name", #Text(NAME)),
          ("icrc1:symbol", #Text(SYMBOL)),
          ("icrc1:decimals", #Nat(Nat8.toNat(DECIMALS))),
          ("fee_rate", #Text("3%"))
        ]
      };
      public shared query func icrc1_supported_standards() : async [ { name: Text; url: Text } ] {
        [ { name = "ICRC-1"; url = "https://github.com/dfinity/ICRC-1" } ]
      };

      // --- ICRC-1 Transfer Implementation with 3% fee ---
      public shared(msg) func icrc1_transfer(args: TransferArgs) : async Result<Nat, TransferError> {
        let caller = msg.caller;
        let fromAcct: Account = { owner = caller; subaccount = args.from_subaccount };
        let toAcct = args.to;

        if (fromAcct.owner == toAcct.owner and fromAcct.subaccount == toAcct.subaccount) {
          return #err(#GenericError { error_code = 1; message = "Cannot send to self" });
        };

        let feeAmt: Nat = (args.amount * 3) / 100;
        if (args.fee != null and args.fee != ?feeAmt) {
          return #err(#BadFee { expected_fee = feeAmt });
        };

        let total = args.amount + feeAmt;
        let fromBal = switch (balances.get(fromAcct)) { case null 0; case (?b) b };
        if (fromBal < total) {
          return #err(#InsufficientFunds { balance = fromBal });
        };

        balances.put(fromAcct, fromBal - total);
        let toBal = switch (balances.get(toAcct)) { case null 0; case (?b) b };
        balances.put(toAcct, toBal + args.amount);

        return #ok(0);
      };

      // --- One-time Payout Function ---
      public shared(msg) func payOut() : async Text {
        let caller = msg.caller; 
        if (claimed.get(caller) == ?true) {
          return "Already Claimed";
        };
        let payoutAmount: Nat = 10_000;
        let depAcct: Account = { owner = deployer; subaccount = null };
        let depBal = switch (balances.get(depAcct)) { case null 0; case (?b) b };
        if (depBal < payoutAmount) {
          return "Insufficient funds in treasury";
        };
        balances.put(depAcct, depBal - payoutAmount);
        balances.put({ owner = caller; subaccount = null }, payoutAmount);
        claimed.put(caller, true);
        return "Payout Successful";
      };

      // --- Debug Utility ---
      public shared query func debugBalances() : async [ (Account, Nat) ] {
        Iter.toArray(balances.entries())
      };
  }
3. On the transfer, 3% of the transfer amount should be deducted from the sender
4. We should have the query functions as per the example
5. The account should be created unique to the users like in the referrence


Prompt 2.
In the frontend of the bank make sure that these things are there:- 
1. functions of transfer DAMN is there with showing 3% charge
2. Check the bank balance of the own account only
3. Show the full name of the own account in the navbar and the bank section
4. payout function with initial payout of 10000 DAMN
5. The frontend UI should be modern and inline css should be used extensibly


Prompt 3.
1. Firstly the balance should not be directly displayed on the fronted rather we should have an option to check balance of the user.
2. The payout function is working but the button is not getting dissabled after the first payout or there is no such message like payout already claimed in the frontend.
3. The nav bar is very much old fashioned and the different pages in the frontend have different themes ... redesign the theme and colour combination of the website and also make it look more professional and reliable for the users as it is a nft marketplace and a dbank. Make sure to use the same theme all over the website.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Prompt 4.
//This is dbank/main.mo
import Debug "mo:base/Debug";
import Text "mo:base/Text";
import Principal "mo:base/Principal";
import Result "mo:base/Result";
import Blob "mo:base/Blob";
import HashMap "mo:base/HashMap";
import Iter "mo:base/Iter";
import Nat8 "mo:base/Nat8";
import Array "mo:base/Array";
import Nat64 "mo:base/Nat64";
import Nat "mo:base/Nat";

// ICRC-1 Token Canister with 3% fee, one-time payout, debugBalances,
// and a compatibility icrc1_transfer_from for your marketplace.
actor class ICRC1Token() = this {
  // ---------- Types ----------
  public type Timestamp = Nat64;
  public type Subaccount = Blob;
  public type Account = { owner : Principal; subaccount : ?Subaccount };

  public type TransferArgs = {
    from_subaccount : ?Subaccount;
    to : Account;
    amount : Nat;
    fee : ?Nat;            // Optional override not supported; enforced as 3%
    memo : ?Blob;
    created_at_time : ?Timestamp;
  };

  public type TransferError = {
    #BadFee : { expected_fee : Nat };
    #InsufficientFunds : { balance : Nat };
    #GenericError : { error_code : Nat; message : Text };
    #TooOld;
    #CreatedInFuture : { ledger_time : Timestamp };
    #Duplicate : { duplicate_of : Nat };
    #TemporarilyUnavailable;
    #BadBurn : { min_burn_amount : Nat };
  };

  public type Value = {
    #Nat : Nat;
    #Int : Int;
    #Text : Text;
    #Blob : Blob;
  };

  public type Std = { name : Text; url : Text };
  public type Result<T, E> = Result.Result<T, E>;

  // ---------- Token constants ----------
  let NAME : Text = "DAMN Token";
  let SYMBOL : Text = "DAMN";
  let DECIMALS : Nat8 = 8;
  let INITIAL_SUPPLY : Nat = 1_000_000_000_000;

  // Use the canister itself as the initial treasury/minting account
  let deployer : Principal = Principal.fromActor(this);
  let treasury : Account = { owner = deployer; subaccount = null };

  // ---------- Stable state ----------
  // Store balances and claimed flags across upgrades
  stable var stableBalances : [ (Account, Nat) ] = [];
  stable var stableClaims : [ (Principal, Bool) ] = [];

  // ---------- In-memory state ----------
  // Equality compares both owner and subaccount (unique per user+sub)
  // Hash uses only owner to keep it simple (valid; may cause collisions).
  var balances : HashMap.HashMap<Account, Nat> = HashMap.HashMap<Account, Nat>(
    256,
    func(a : Account, b : Account) : Bool =
      a.owner == b.owner and a.subaccount == b.subaccount,
    // DON'T annotate return type here — let compiler infer from Principal.hash
    func(a : Account) = Principal.hash(a.owner)
  );

  var claimed : HashMap.HashMap<Principal, Bool> =
    HashMap.HashMap<Principal, Bool>(256, Principal.equal, Principal.hash);

  // ---------- Upgrade hooks ----------
  system func preupgrade() {
    stableBalances := Iter.toArray(balances.entries());
    stableClaims := Iter.toArray(claimed.entries());
  };

  system func postupgrade() {
    balances := HashMap.fromIter<Account, Nat>(
      stableBalances.vals(),
      256,
      func(a : Account, b : Account) : Bool =
        a.owner == b.owner and a.subaccount == b.subaccount,
      func(a : Account) = Principal.hash(a.owner)
    );

    claimed := HashMap.HashMap<Principal, Bool>(256, Principal.equal, Principal.hash);
    for ((p, wasClaimed) in stableClaims.vals()) {
      claimed.put(p, wasClaimed);
    };
  };

  // ---------- Constructor mint ----------
  // Mint the full initial supply to the treasury (the canister itself).
  // Executed at install time.
  ignore do {
    let cur = switch (balances.get(treasury)) { case (?b) b; case null 0 };
    balances.put(treasury, cur + INITIAL_SUPPLY);
  };

  // ---------- ICRC-1 queries ----------
  public shared query func icrc1_name() : async Text { NAME };

  public shared query func icrc1_symbol() : async Text { SYMBOL };

  public shared query func icrc1_decimals() : async Nat8 { DECIMALS };

  // We implement dynamic % fee, so the fixed base fee is 0.
  public shared query func icrc1_fee() : async Nat { 0 };

  public shared query func icrc1_total_supply() : async Nat {
    var sum : Nat = 0;
    for ((_, bal) in balances.entries()) { sum += bal };
    sum
  };

  public shared query func icrc1_minting_account() : async ?Account {
    ?treasury
  };

  public shared query func icrc1_balance_of(account : Account) : async Nat {
    switch (balances.get(account)) {
      case (?b) b;
      case null 0;
    }
  };

  public shared query func icrc1_metadata() : async [ (Text, Value) ] {
    [
      ("icrc1:name", #Text(NAME)),
      ("icrc1:symbol", #Text(SYMBOL)),
      ("icrc1:decimals", #Nat(Nat8.toNat(DECIMALS))),
      // Advertise the dynamic percentage fee here:
      ("fee_rate", #Text("3% of transfer amount"))
    ]
  };

  public shared query func icrc1_supported_standards() : async [Std] {
    [ { name = "ICRC-1"; url = "https://github.com/dfinity/ICRC-1" } ]
  };

  // ---------- Core transfer with 3% fee ----------
  public shared(msg) func icrc1_transfer(args : TransferArgs)
    : async Result<Nat, TransferError>
  {
    let fromAcct : Account = { owner = msg.caller; subaccount = args.from_subaccount };
    let toAcct : Account = args.to;

    if (fromAcct.owner == toAcct.owner and fromAcct.subaccount == toAcct.subaccount) {
      return #err(#GenericError { error_code = 1; message = "Cannot send to self" });
    };

    // dynamic 3% fee
    let feeAmt : Nat = (args.amount * 3) / 100;

    // If caller supplied a fee, enforce it equals 3%
    if (args.fee != null and args.fee != ?feeAmt) {
      return #err(#BadFee { expected_fee = feeAmt });
    };

    let total = args.amount + feeAmt;

    let fromBal =
      switch (balances.get(fromAcct)) { case (?b) b; case null 0 };

    if (fromBal < total) {
      return #err(#InsufficientFunds { balance = fromBal });
    };

    // debit sender
    balances.put(fromAcct, fromBal - total);

    // credit receiver with amount (fee is *not* added to receiver)
    let toBal = switch (balances.get(toAcct)) { case (?b) b; case null 0 };
    balances.put(toAcct, toBal + args.amount);

    // credit fee to treasury
    let treasBal = switch (balances.get(treasury)) { case (?b) b; case null 0 };
    balances.put(treasury, treasBal + feeAmt);

    // ICRC-1 returns a block height; we return 0 as a placeholder
    #ok(0)
  };

  // ---------- One-time payout per principal ----------
  public shared(msg) func payOut() : async Text {
    let caller = msg.caller;

    switch (claimed.get(caller)) {
      case (?true) { return "Already Claimed" };
      case _ {};
    };

    let payoutAmount : Nat = 10_000;

    // Pay from treasury
    let treasBal = switch (balances.get(treasury)) { case (?b) b; case null 0 };
    if (treasBal < payoutAmount) {
      return "Insufficient funds in treasury";
    };

    balances.put(treasury, treasBal - payoutAmount);

    let userAcct : Account = { owner = caller; subaccount = null };
    let userBal = switch (balances.get(userAcct)) { case (?b) b; case null 0 };
    balances.put(userAcct, userBal + payoutAmount);

    claimed.put(caller, true);
    "Payout Successful"
  };

  // ---------- Debug utility ----------
  public shared query func debugBalances() : async [ (Account, Nat) ] {
    Iter.toArray(balances.entries())
  };

  // ---------- Compatibility shim for your Marketplace ----------
  // Your Marketplace expects: icrc1_transfer_from(TransferArgs) -> { error : ?Text; height : Nat64 }
  // We implement it by calling icrc1_transfer with msg.caller as "from".
  public shared(msg) func icrc1_transfer_from(args : TransferArgs)
    : async { error : ?Text; height : Nat64 }
  {
    // adapt "to" already an Account; fee logic the same
    let res = await icrc1_transfer(args);
    switch (res) {
      case (#ok(_height)) { return { error = null; height = 0 }; };
      case (#err(e)) {
        let msgText : Text = switch e {
          case (#BadFee { expected_fee }) { "BadFee. expected=" # Nat.toText(expected_fee) };
          case (#InsufficientFunds { balance }) { "InsufficientFunds. balance=" # Nat.toText(balance) };
          case (#GenericError { error_code; message }) {
            "GenericError(" # Nat.toText(error_code) # "): " # message
          };
          case (#TooOld) { "TooOld" };
          case (#CreatedInFuture { ledger_time }) {
            // ledger_time is Nat64; convert to Nat for Nat.toText
            "CreatedInFuture(" # Nat.toText(Nat64.toNat(ledger_time)) # ")"
          };
          case (#Duplicate { duplicate_of }) { "Duplicate(" # Nat.toText(duplicate_of) # ")" };
          case (#TemporarilyUnavailable) { "TemporarilyUnavailable" };
          case (#BadBurn { min_burn_amount }) {
            "BadBurn. min=" # Nat.toText(min_burn_amount)
          };
        };
        { error = ?msgText; height = 0 };
      };
    }
  };
}


//This is marketplace/main.mo
import Nat "mo:base/Nat";
import Nat64 "mo:base/Nat64";
import Text "mo:base/Text";
import Principal "mo:base/Principal";
import HashMap "mo:base/HashMap";
import Option "mo:base/Option";
import Array "mo:base/Array";
import Time "mo:base/Time";
import Hash "mo:base/Hash";
import Debug "mo:base/Debug";
import Iter "mo:base/Iter";

// Marketplace actor class
actor class Marketplace(tokenCid: Principal, nftCid: Principal) = this {

  // -------- ICRC-1 Token Interface --------
  public type TransferArgs = {
    from_subaccount : ?[Nat8];
    to : Principal;
    amount : Nat;
    fee : ?Nat;
    memo : ?[Nat8];
    created_at_time : ?Nat64;
  };
  public type ICRC1 = actor {
    icrc1_transfer_from : (TransferArgs) -> async { error : ?Text; height : Nat64 };
  };

  // ------ Types ------
  public type TokenId = Nat;
  public type Metadata = { uri: Text; name: Text };
  public type NFT = actor {
    icrc7_ownerOf : (TokenId) -> async ?Principal;
    icrc7_approve : (Principal, TokenId) -> async Bool;
    icrc7_transfer : (Principal, TokenId) -> async Bool;
    icrc7_metadata : (TokenId) -> async ?Metadata;
    icrc7_getApproved : (TokenId) -> async ?Principal;
  };
  public type Auction = {
    tokenId       : TokenId;
    nftCid        : Principal;
    owner         : Principal;
    minBid        : Nat;
    highestBid    : Nat;
    highestBidder : ?Principal;
    endTime       : ?Nat64;
    metadata      : Metadata;
  };

  // ------ State ------
  let nft : NFT = actor(Principal.toText(nftCid));
  let token : ICRC1 = actor(Principal.toText(tokenCid));

  // in-memory HashMap for listings
  var listings : HashMap.HashMap<TokenId, Auction> =
    HashMap.HashMap<TokenId, Auction>(32, Nat.equal, Hash.hash);

  // ------ List Auction ------
  public shared(msg) func listForAuction(tokenId: TokenId, minBid: Nat, durationSec: Nat64) : async ?Text {
    let metaOpt = await nft.icrc7_metadata(tokenId);
    switch (metaOpt) {
      case null { return ?"Missing metadata" };
      case (?meta) {
        let ownerOpt = await nft.icrc7_ownerOf(tokenId);
        switch (ownerOpt) {
          case null { return ?"Not NFT owner" };
          case (?owner) { if (owner != msg.caller) { return ?"Not NFT owner" } };
        };
        let approvedOpt = await nft.icrc7_getApproved(tokenId);
        switch (approvedOpt) {
          case null { return ?"Marketplace not approved" };
          case (?approver) {
            if (approver != Principal.fromActor(this)) { return ?"Marketplace not approved" };
          };
        };

        // compute end time as Nat64
        let now64 : Nat64 = Nat64.fromIntWrap(Time.now());
        let addNanos : Nat64 = Nat64.mul(durationSec, Nat64.fromNat(1_000_000_000));
        let endTime64 : Nat64 = Nat64.add(now64, addNanos);

        let auction : Auction = {
          tokenId = tokenId;
          nftCid = nftCid;
          owner = msg.caller;
          minBid = minBid;
          highestBid = 0;
          highestBidder = null;
          endTime = ?endTime64;
          metadata = meta;
        };
        listings.put(tokenId, auction);
        return null;
      };
    };
  };

  // ------ Bid ------
  public shared(msg) func bid(tokenId: TokenId, bidAmt: Nat) : async ?Text {
    switch (listings.get(tokenId)) {
      case null { return ?"Not listed" };
      case (?auction) {
        let now64 : Nat64 = Nat64.fromIntWrap(Time.now());
        let ended = switch (auction.endTime) {
          case null { false };
          case (?end) end < now64;
        };
        if (ended) { return ?"Auction has ended" };

        let minValid =
          if (auction.highestBid == 0)
            auction.minBid
          else
            auction.highestBid + (auction.highestBid * 5) / 100;
        if (bidAmt < minValid) { return ?("Bid < min (" # Nat.toText(minValid) # ")") };

        // --- Payment: transfer bidAmt to escrow (marketplace canister) ---
        let payRes = await token.icrc1_transfer_from({
          from_subaccount = null;
          to = Principal.fromActor(this);
          amount = bidAmt;
          fee = null;
          memo = null;
          created_at_time = null;
        });
        switch (payRes.error) {
          case (?err) { return ?("Payment failed: " # err) };
          case null { /* proceed */ };
        };

        // --- Refund previous highest bidder, if any ---
        switch (auction.highestBidder) {
          case (?prev) {
            if (auction.highestBid > 0) {
              // Attempt refund (ignore failure)
              ignore await token.icrc1_transfer_from({
                from_subaccount = null;
                to = prev;
                amount = auction.highestBid;
                fee = null;
                memo = null;
                created_at_time = null;
              });
            };
          };
          case null { /* nothing to refund */ };
        };

        // --- Update auction record ---
        let updated : Auction = {
          tokenId = auction.tokenId;
          nftCid = auction.nftCid;
          owner = auction.owner;
          minBid = auction.minBid;
          highestBid = bidAmt;
          highestBidder = ?msg.caller;
          endTime = auction.endTime;
          metadata = auction.metadata;
        };
        listings.put(tokenId, updated);
        return null;
      };
    };
  };

  // ------ Settle Auction ------
  public shared(msg) func settleAuction(tokenId: TokenId) : async ?Text {
    switch (listings.get(tokenId)) {
      case null { return ?"No such auction" };
      case (?auction) {
        let now64 : Nat64 = Nat64.fromIntWrap(Time.now());
        switch (auction.endTime) {
          case null { return ?"Auction has no end time" };
          case (?end) { if (now64 < end) { return ?"Auction has not ended yet" } };
        };
        switch (auction.highestBidder) {
          case null { return ?"No winner" };
          case (?winner) {
            // --- Pay seller out of escrow ---
            let paySeller = await token.icrc1_transfer_from({
              from_subaccount = null;
              to = auction.owner;
              amount = auction.highestBid;
              fee = null;
              memo = null;
              created_at_time = null;
            });
            switch (paySeller.error) {
              case (?err) { return ?("Payout failed: " # err) };
              case null { /* proceed */ };
            };
            // --- Transfer NFT to winner ---
            ignore await nft.icrc7_transfer(winner, tokenId);
            // --- Close auction ---
            listings.delete(tokenId);
            return null;
          };
        };
      };
    };
  };

  // ------ Queries ------
  public query func getActiveAuctions() : async [Auction] {
    let now64 : Nat64 = Nat64.fromIntWrap(Time.now());
    let ids = Iter.toArray<TokenId>(listings.keys());
    // Map ids -> auctions (should exist)
    let auctions = Array.map<TokenId, Auction>(ids, func(id: TokenId) : Auction {
      switch (listings.get(id)) {
        case (?a) a;
        case null { Debug.trap("Invariant violated: missing auction for id") };
      }
    });
    // Filter active auctions (no endTime or end > now)
    Array.filter<Auction>(auctions, func(a: Auction) : Bool {
      switch (a.endTime) {
        case null { true };
        case (?end) end > now64;
      }
    })
  };
}


//This is nft/main.mo
import Nat "mo:base/Nat";
import Text "mo:base/Text";
import Principal "mo:base/Principal";
import HashMap "mo:base/HashMap";
import Array "mo:base/Array";
import Option "mo:base/Option";
import Hash "mo:base/Hash";
import Nat32 "mo:base/Nat32";

actor class NFTCanister() = this {

  // --- Types ---
  public type TokenId = Nat;
  public type Metadata = { uri: Text; name: Text };
  public type NFT = { owner: Principal; metadata: Metadata; approved: ?Principal };

  // --- State ---
  
//   transient var tokens : HashMap.HashMap<TokenId, NFT> = HashMap.HashMap<TokenId, NFT>(64, Nat.equal, Nat.hash);
  var tokens : HashMap.HashMap<TokenId, NFT> =
    HashMap.HashMap<TokenId, NFT>(
      64,
      Nat.equal,
      Hash.hash
    );
  stable var nextTokenId: TokenId = 0;
  // --- Mint ---
  public shared(msg) func icrc7_mint(metadata: Metadata) : async TokenId {
    let id = nextTokenId;
    nextTokenId += 1;
    let nft : NFT = { owner = msg.caller; metadata = metadata; approved = null };
    tokens.put(id, nft);
    id
  };

  // --- Transfer (owner or approved) ---
  public shared(msg) func icrc7_transfer(to: Principal, id: TokenId) : async Bool {
    switch (tokens.get(id)) {
      case (?nft) {
        let isOwner = nft.owner == msg.caller;
        let isApproved = switch (nft.approved) {
          case (?p) p == msg.caller;
          case null false;
        };
        if (isOwner or isApproved) {
          let updated : NFT = { owner = to; metadata = nft.metadata; approved = null };
          tokens.put(id, updated);
          return true;
        } else {
          return false;
        }
      };
      case null return false;
    }
  };

  // --- Approve ---
  public shared(msg) func icrc7_approve(operator: Principal, id: TokenId) : async Bool {
    switch (tokens.get(id)) {
      case (?nft) {
        if (nft.owner == msg.caller) {
          let updated : NFT = { owner = nft.owner; metadata = nft.metadata; approved = ?operator };
          tokens.put(id, updated);
          return true;
        } else {
          return false;
        }
      };
      case null return false;
    }
  };

  // --- Revoke ---
  public shared(msg) func icrc7_revoke(id: TokenId) : async Bool {
    switch (tokens.get(id)) {
      case (?nft) {
        if (nft.owner == msg.caller) {
          let updated : NFT = { owner = nft.owner; metadata = nft.metadata; approved = null };
          tokens.put(id, updated);
          return true;
        } else {
          return false;
        }
      };
      case null return false;
    }
  };

  // --- Queries ---

  public query func icrc7_ownerOf(id: TokenId) : async ?Principal {
    switch (tokens.get(id)) {
      case (?nft) ?nft.owner;
      case null null;
    }
  };

  public query func icrc7_getApproved(id: TokenId) : async ?Principal {
    switch (tokens.get(id)) {
      case (?nft) nft.approved;
      case null null;
    }
  };

  public query func icrc7_tokenUri(id: TokenId) : async ?Text {
    switch (tokens.get(id)) {
      case (?nft) ?nft.metadata.uri;
      case null null;
    }
  };

  // Returns all token ids owned by `owner`
  public query func icrc7_tokensOf(owner: Principal) : async [TokenId] {
    let n = nextTokenId;
    let tokensArr = Array.tabulate<TokenId>(n, func(i: Nat): Nat { i });
    Array.filter<TokenId>(tokensArr, func (id) : Bool {
      switch (tokens.get(id)) { case (?nft) nft.owner == owner; case null false }
    })
  };

  public query func icrc7_metadata(id: TokenId) : async ?Metadata {
    switch (tokens.get(id)) {
      case (?nft) ?nft.metadata;
      case null null;
    }
  };
};

Rewrite the marketplace/main.mo with the following logic
1. The minting fees is randomly between 40-60% of the desired current amount

2. The base price of bidding will be less than 220% of the current price

3. On the sale of NFT 5% of the profit will be transferred to the bank

4. Whenever user makes a bid on any NFT, the amount he/she has bid will be freezed on his/her account i.e. his/her balance should not go bellow the freeze amount. Same user can have multiple bids on different nfts.

5. Whenever transfer happens it releases the bid and that amount will be transferred to the seller.

6. If someone else makes a higher bid the freeze will be released to the current user and new user's account will be made a freeze.

7. In the frontend the bid amount can be increased with at least the 5% of current bid. This should be ensured in the frontend first but also on the backend for cross verification once it passes the frontend.


This can require us to change dbank marketplace and nft /main.mo

----------------------------------------------------------------------------------------------------------------------------------------------


In marketplace/main.mo, I don't want to store the NFT's in form of objects rather I want to store them as canisters

import Nat "mo:base/Nat";
import Principal "mo:base/Principal";
import Random "mo:base/Random";
import Debug "mo:base/Debug";
import TrieMap "mo:base/TrieMap";
import Hash "mo:base/Hash";
import Iter "mo:base/Iter";
import Text "mo:base/Text";
import Nat8 "mo:base/Nat8";
import Blob "mo:base/Blob";

actor class Marketplace(dBankId : Principal) = this {


  // ---------------- NFT & Marketplace Types ----------------

  // The NFT record type needs to be public to be used in public function signatures.
  public type NFT = {
    id : Nat;
    owner : Principal;
    price : Nat;
    forSale : Bool;
  };

  public type TransferResult = {
    #Ok : Nat;
    #Err : Text;
  };


  // var nfts : TrieMap.TrieMap<Nat, NFT> = TrieMap.TrieMap(Nat.equal, Nat.hash);

  stable var nextNFTId : Nat = 0;

  // Freeze ledger: (user, nftId) -> frozenAmount
  // Helper functions are required to use a tuple as a TrieMap key.
  let hashTuple = func(k: (Principal, Nat)): Hash.Hash {
      // Combine both into a Text and then hash to Nat32, then promote to Nat
      let txt = Principal.toText(k.0) # Nat.toText(k.1);
      return Text.hash(txt);
  };

  let equalTuple = func(k1: (Principal, Nat), k2: (Principal, Nat)): Bool {
      return k1.0 == k2.0 and k1.1 == k2.1;
  };
  // The key for 'freezes' is a tuple (Principal, Nat) and the value is the bid amount (Nat).
  stable var stableFreezes : [((Principal, Nat), Nat)] = [];

  var freezes : TrieMap.TrieMap<(Principal, Nat), Nat> = TrieMap.TrieMap(equalTuple, hashTuple);

  system func preupgrade() {
    stableFreezes := Iter.toArray(freezes.entries());    
    stableNFTs := Iter.toArray(nfts.entries());
    // stableFreezes := Iter.toArray(freezes.entries());
};

system func postupgrade() {
    freezes := TrieMap.TrieMap(equalTuple, hashTuple);
    for ((key, amount) in stableFreezes.vals()) {
        freezes.put(key, amount);
    };
    nfts := TrieMap.TrieMap(Nat.equal, func(n : Nat) : Hash.Hash {
      Text.hash(Nat.toText(n))
    });

    for ((id, nft) in stableNFTs.vals()) {
        nfts.put(id, nft);
    };

    // freezes := TrieMap.TrieMap(equalTuple, hashTuple);
    // for ((key, amount) in stableFreezes.vals()) {
    //     freezes.put(key, amount);
    // };
};

stable var stableNFTs : [(Nat, NFT)] = [];

var nfts : TrieMap.TrieMap<Nat, NFT> = TrieMap.TrieMap(
    Nat.equal,
    func(n : Nat) : Hash.Hash { Text.hash(Nat.toText(n)) }
);



  // Reference to dBank canister
  // Corrected the actor reference syntax and function signatures.
  let dBank : actor {
    icrc1_balance_of : shared query ({ owner : Principal; subaccount : ?[Nat8] }) -> async Nat;
    icrc1_transfer : shared ({
      from_subaccount : ?[Nat8];
      to : { owner : Principal; subaccount : ?[Nat8] };
      amount : Nat;
      fee : ?Nat;
      memo : ?[Nat8];
      created_at_time : ?Nat64;
    }) -> async TransferResult;
  } = actor (Principal.toText(dBankId));


  // ---------------- Minting ----------------
  public shared(msg) func mintNFT(desiredPrice : Nat) : async Text {
    // Random mint fee between 40–60%
    let rnd = await Random.blob();
    // Corrected the way a random Nat is generated from a Blob.
    let r = Nat8.toNat(Blob.toArray(rnd)[0]) % 21;
    let feePercent = 40 + r; // 40–60

    let mintFee = (desiredPrice * feePercent) / 100;
    let finalPrice = desiredPrice;

    let nft : NFT = {
      id = nextNFTId;
      owner = msg.caller;
      price = finalPrice;
      forSale = true;
    };

    nfts.put(nextNFTId, nft);
    nextNFTId += 1;

    return "NFT minted with ID " # Nat.toText(nft.id) #
            " at price " # Nat.toText(nft.price) #
            " (Fee taken: " # Nat.toText(mintFee) # ")";
  };

  // ---------------- Bidding ----------------
  public shared(msg) func placeBid(nftId : Nat, bidAmount : Nat) : async Text {
    switch (nfts.get(nftId)) {
      // Added a colon to the 'case' statement.
      case null {return "NFT does not exist"};
      case (?nft) {
        if (not nft.forSale) return "NFT not for sale";

        // Bid must be <= 220% of current price
        if (bidAmount > (nft.price * 220) / 100) {
          return "Bid too high (must be <= 220% of current price)";
        };

        // Bid must be >= current price * 105% (min +5%)
        if (bidAmount < (nft.price * 105) / 100) {
          return "Bid too low (must be at least +5% of current price)";
        };

        // Check user balance
        let bal = await dBank.icrc1_balance_of({ owner = msg.caller; subaccount = null });
        if (bal < bidAmount) return "Insufficient balance";

        // Release previous freeze if exists
        // Corrected the 'for' loop syntax for iterating over map entries.
        for ((key, amount) in freezes.entries()) {
          if (key.1 == nftId) { // same NFT
            if (key.0 != msg.caller) {
              // The correct method to remove an entry is 'remove', not 'delete'.
              ignore freezes.remove(key);
            };
          };
        };

        // Freeze new bidder
        freezes.put((msg.caller, nftId), bidAmount);

        // Update NFT price (highest bid so far)
        let updatedNFT = { nft with price = bidAmount };
        nfts.put(nftId, updatedNFT);

        return "Bid placed successfully with freeze of " # Nat.toText(bidAmount);
      };
    };
  };

  // ---------------- Transfer (Finalize Sale) ----------------
  public shared(msg) func finalizeSale(nftId : Nat) : async Text {
    switch (nfts.get(nftId)) {
      // Added a colon to the 'case' statement.
      case null { "NFT does not exist" };
      case (?nft) {
        if (not nft.forSale) return "NFT not for sale";

        // Find winner
        var winner : ?Principal = null;
        var winAmount : Nat = 0;
        // Corrected the 'for' loop syntax.
        for ((key, amount) in freezes.entries()) {
          // Replaced 'and' with the correct logical operator '&&'.
          if (key.1 == nftId and amount > winAmount) {
            winner := ?key.0;
            winAmount := amount;
          };
        };

        switch (winner) {
          // Added a colon to the 'case' statement.
          case null {return "No bids to finalize"};
          case (?buyer) {
            if (buyer == nft.owner) return "Owner cannot buy own NFT";

            // Calculate 5% profit cut
            let profit = if (winAmount > nft.price) { winAmount - nft.price } else { 0 };
            let fee = (profit * 5) / 100;
            let sellerReceives = winAmount - fee;

            // Transfer to seller
            // Used 'let _ = await' to correctly ignore the async result.
            let _ = await dBank.icrc1_transfer({
              from_subaccount = null;
              to = { owner = nft.owner; subaccount = null };
              amount = sellerReceives;
              fee = null;
              memo = null;
              created_at_time = null;
            });

            // Transfer fee to bank (owner=bank principal)
            if (fee > 0) {
              // Used a principal literal, which is safer than 'fromText'.
              let _ = await dBank.icrc1_transfer({
                from_subaccount = null;
                to = { owner = dBankId; subaccount = null };
                amount = fee;
                fee = null;
                memo = null;
                created_at_time = null;
              });
            };

            // Release all freezes for this NFT
            // Corrected the 'for' loop syntax.
            for ((key, _) in freezes.entries()) {
              if (key.1 == nftId) {
                // The correct method is 'remove', not 'delete'.
                ignore freezes.remove(key);
              };
            };

            // Transfer ownership
            let updatedNFT = { nft with owner = buyer; forSale = false };
            nfts.put(nftId, updatedNFT);

            // Removed the erroneous semicolon at the end of the return statement.
            return "NFT " # Nat.toText(nftId) # " sold to " # Principal.toText(buyer) #
                   " for " # Nat.toText(winAmount) #
                   ". Seller received " # Nat.toText(sellerReceives) #
                   ", Fee sent: " # Nat.toText(fee)
          };
        };
      };
    };
  };

  // ---------------- Utility ----------------
  public query func getNFT(nftId : Nat) : async ?NFT {
    nfts.get(nftId)
  };

  public query func getAllNFTs() : async [NFT] {
    Iter.toArray(nfts.vals())
  };

};



this is nft/main.mo
import Nat "mo:base/Nat";
import Int "mo:base/Int";
import Text "mo:base/Text";
import Principal "mo:base/Principal";
import HashMap "mo:base/HashMap";
import Array "mo:base/Array";
import Option "mo:base/Option";
import Hash "mo:base/Hash";
import Time "mo:base/Time";
import Random "mo:base/Random";
import Nat8 "mo:base/Nat8";
import Blob "mo:base/Blob";

// ----------------- Types -----------------


// ----------------- Actor -----------------
actor class NFTCanister(dBank: actor {
    icrc1_balance_of : shared query ({ owner : Principal; subaccount : ?[Nat8] }) -> async Nat;
    icrc1_transfer : shared ({
      from_subaccount : ?[Nat8];
      to : { owner : Principal; subaccount : ?[Nat8] };
      amount : Nat;
      fee : ?Nat;
      memo : ?[Nat8];
      created_at_time : ?Nat64;
    }) -> async { #Ok : Nat; #Err : Text };
  }) = this {

  public type TokenId = Nat;
  public type Metadata = { uri: Text; name: Text };
  public type NFT = {
    owner: Principal;
    metadata: Metadata;
    approved: ?Principal;
    currentPrice: Nat;
    basePrice: Nat;
    maxPrice: Nat;
    isOnBid: Bool;
    bidEndTime: ?Int;
    purchaser: ?Principal;
  };
  // --- State ---
  var tokens: HashMap.HashMap<TokenId, NFT> = HashMap.HashMap<TokenId, NFT>(
    64, Nat.equal, Hash.hash
  );
  stable var nextTokenId: TokenId = 0;

  // ----------------- Mint -----------------
  public shared(msg) func icrc7_mint(metadata: Metadata, desiredPrice: Nat) : async TokenId {
    let id = nextTokenId;
    nextTokenId += 1;

    // minting fee = random 40–60% of desired price
    let randBlob = await Random.blob();
    let randVal = Nat8.toNat(Blob.toArray(randBlob)[0]) % 21; // 0..20
    let feePercent = 40 + randVal;
    let mintFee = desiredPrice * feePercent / 100;

    let nft: NFT = {
      owner = msg.caller;
      metadata = metadata;
      approved = null;
      currentPrice = desiredPrice - mintFee;
      basePrice = desiredPrice;
      maxPrice = desiredPrice * 220 / 100; // max < 220%
      isOnBid = false;
      bidEndTime = null;
      purchaser = null;
    };
    tokens.put(id, nft);
    id
  };

  // ----------------- Transfer -----------------
  public shared(msg) func icrc7_transfer(to: Principal, id: TokenId, price: Nat) : async Bool {
    switch (tokens.get(id)) {
      case (?nft) {
        let isOwner = nft.owner == msg.caller;
        let isApproved = switch (nft.approved) {
          case (?p) p == msg.caller;
          case null false;
        };
        if (isOwner or isApproved) {
          // Transfer + freeze release logic can be implemented with dBank here
          let profit = if (price > nft.currentPrice) price - nft.currentPrice else 0;
          let bankFee = profit * 5 / 100;

          // Transfer to bank and seller would be done via dBank
          // Example: await dBank.icrc1_transfer({...})

          let updated: NFT = {
            owner = to;
            metadata = nft.metadata;
            approved = null;
            currentPrice = price - bankFee;
            basePrice = nft.basePrice;
            maxPrice = nft.maxPrice;
            isOnBid = false;
            bidEndTime = null;
            purchaser = null;
          };
          tokens.put(id, updated);
          true
        } else false;
      };
      case null return false;
    }
  };

  // ----------------- Approve/Revoke -----------------
  public shared(msg) func icrc7_approve(operator: Principal, id: TokenId) : async Bool {
    switch (tokens.get(id)) {
      case (?nft) {
        if (nft.owner == msg.caller) {
          let updated: NFT = { nft with approved = ?operator };
          tokens.put(id, updated);
          true
        } else false;
      };
      case null return false;
    }
  };

  public shared(msg) func icrc7_revoke(id: TokenId) : async Bool {
    switch (tokens.get(id)) {
      case (?nft) {
        if (nft.owner == msg.caller) {
          let updated: NFT = { nft with approved = null };
          tokens.put(id, updated);
          true
        } else false;
      };
      case null return false;
    }
  };

  // ----------------- Auction Logic -----------------
  public shared(msg) func startBid(id: TokenId, durationSeconds: Nat, base: Nat) : async Bool {
    switch(tokens.get(id)) {
      case (?nft) {
        if (nft.owner != msg.caller) return false;
        if (base >= nft.maxPrice) return false;
        let updated = { nft with
          isOnBid = true;
          bidEndTime = ?(Time.now() + (Int.abs(durationSeconds) * 1_000_000_000));
          basePrice = base;
        };
        tokens.put(id, updated);
        true
      };
      case null return false;
    }
  };

  public shared(msg) func setBid(id: TokenId, newBid: Nat) : async Bool {
    switch(tokens.get(id)) {
      case (?nft) {
        if (not nft.isOnBid) return false;
        if (newBid < nft.basePrice) return false;
        if (newBid < nft.currentPrice + (nft.currentPrice * 5 / 100)) return false;

        let updated = { nft with currentPrice = newBid; purchaser = ?msg.caller };
        tokens.put(id, updated);
        true
      };
      case null return false;
    }
  };

  public shared(msg) func finalizeBid(id: TokenId) : async ?Principal {
    switch(tokens.get(id)) {
      case (?nft) {
        switch(nft.bidEndTime) {
          case (?t) {
            if (Time.now() >= t and nft.purchaser != null) {
              switch (nft.purchaser) {
                case (?winner) {
                  let profit = if (nft.currentPrice > nft.basePrice) nft.currentPrice - nft.basePrice else 0;
                  let bankFee = profit * 5 / 100;

                  let updated = { nft with
                    owner = winner;
                    isOnBid = false;
                    bidEndTime = null;
                    purchaser = null;
                    currentPrice = nft.currentPrice - bankFee
                  };
                  tokens.put(id, updated);
                  return ?winner;
                };
                case null { return null };
              };
            };
            return null;
          };
          case null { return null };
        };
      };
      case null { return null };
    };
};


  // ----------------- Queries -----------------
  public query func icrc7_ownerOf(id: TokenId) : async ?Principal {
    switch (tokens.get(id)) { case (?nft) ?nft.owner; case null null }
  };

  public query func icrc7_getApproved(id: TokenId) : async ?Principal {
    switch (tokens.get(id)) { case (?nft) nft.approved; case null null }
  };

  public query func icrc7_tokenUri(id: TokenId) : async ?Text {
    switch (tokens.get(id)) { case (?nft) ?nft.metadata.uri; case null null }
  };

  public query func icrc7_tokensOf(owner: Principal) : async [TokenId] {
    let n = nextTokenId;
    let tokensArr = Array.tabulate<TokenId>(n, func(i: Nat): Nat { i });
    Array.filter<TokenId>(tokensArr, func (id) : Bool {
      switch (tokens.get(id)) { case (?nft) nft.owner == owner; case null false }
    })
  };

  public query func icrc7_metadata(id: TokenId) : async ?Metadata {
    switch (tokens.get(id)) { case (?nft) ?nft.metadata; case null null }
  };

  public query func getDetails(id: TokenId) : async ?NFT {
    tokens.get(id)
  };
};


I want that on successfully minting an nft on marketplace, a new NFT cannister is minted.

Also check before minting whether 60% of the desired amount is available on the account of the user if not return "Not sufficient balance to mint the NFT."

this is the balance check function in the dbank container
 public shared query func icrc1_balance_of(account : Account) : async Nat {
    switch (balances.get(account)) {
      case (?b) b;
      case null 0;
    }
  };
