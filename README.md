# `Tulips`

Welcome to your new `Tulips` project and to the Internet Computer development community. By default, creating a new project adds this README and some template files to your project directory. You can edit these template files to customize your project and to include your own code to speed up the development cycle.

To get started, you might want to explore the project directory structure and the default configuration file. Working with this project in your development environment will not affect any production deployment or identity tokens.

To learn more before you start working with `Tulips`, see the following documentation available online:

- [Quick Start](https://internetcomputer.org/docs/current/developer-docs/setup/deploy-locally)
- [SDK Developer Tools](https://internetcomputer.org/docs/current/developer-docs/setup/install)
- [Motoko Programming Language Guide](https://internetcomputer.org/docs/current/motoko/main/motoko)
- [Motoko Language Quick Reference](https://internetcomputer.org/docs/current/motoko/main/language-manual)

If you want to start working on your project right away, you might want to try the following commands:

```bash
cd Tulips/
dfx help
dfx canister --help
```

## Running the project locally

If you want to test your project locally, you can use the following commands:

```bash
# Starts the replica, running in the background
dfx start --background

# Deploys your canisters to the replica and generates your candid interface
dfx deploy
```

Once the job completes, your application will be available at `http://localhost:4943?canisterId={asset_canister_id}`.

If you have made changes to your backend canister, you can generate a new candid interface with

```bash
npm run generate
```

at any time. This is recommended before starting the frontend development server, and will be run automatically any time you run `dfx deploy`.

If you are making frontend changes, you can start a development server with

```bash
npm start
```

Which will start a server at `http://localhost:8080`, proxying API requests to the replica at port 4943.

### Note on frontend environment variables

If you are hosting frontend code somewhere without using DFX, you may need to make one of the following adjustments to ensure your project does not fetch the root key in production:

- set`DFX_NETWORK` to `ic` if you are using Webpack
- use your own preferred method to replace `process.env.DFX_NETWORK` in the autogenerated declarations
  - Setting `canisters -> {asset_canister_id} -> declarations -> env_override to a string` in `dfx.json` will replace `process.env.DFX_NETWORK` with the string in the autogenerated declarations
- Write your own `createActor` constructor

-----------------------------------------------------------------------------------------------------------

It asks two canisters in arguments: 

In another terminal, Run these two commands:

1.  dfx canister id dbank  -> You will get a principal id that will be the first argument
2.  dfx canister id nft    -> This will give the second argument


------------------------------------------------------------------------------------------------------------


1. Bank - User can check its own balance, request payout(initial amount of 1000 to be given to the user while opening the account and transfer the tokens to the other users)

2. NFT Marketplace - User can mint NFT, auction NFT and bid on the auctioned NFTs, along with that the currently owned NFT's will be visible to the user

There are three points in this project:

i. User who performs activities 

ii. Bank (It is the main backend cannister which stores all the functions and properties with which user interacts)

Here are the properties and methods of the bank:

Name of token - DAMN Tokens

Symbol of token - DAMN

Initial supply - 1000000000000

List of accounts

List of users who have claimed the payout

Check balance function 

Transfer Token Function

List of Balances function

Freeze certain amount of the user - explained further in the extended rules

Release the freeze amount -  explained further in the extended rules

List of NFT's

Map of NFT's with the current owner

List of biddings

Mint new NFT
Get Owned NFT's
Show bid NFTs to the users - their own NFTs as well but as disabled cards
get NFT data
Map of timings of the bid NFTs
Transfer ownership when timer runs out
Ping the users on transfer
iii. NFT - This is the cannister that holds the data of NFTs
Here are the functions and properties inside the NFT actor class
NFT Name
NFT owner name
IPFS image URL
Cannister Id
Transfer Ownership
Current Price
Bid status
Time stamp of Bid
Bid timer - reflected on frontend as well
Transfer Ownership - triggered immediately once the timer hits 24 hrs
Base price
Max price
set bids
set purchaser(only if amount > base price)
sell bid (change bid)


Extended rules - 
1. Whenever new account gets created, the payout option should be made available ... which was there in the last DBank app as well -- Done

2. The transfer fees is 3% of the total transaction amount        -------------------------------------------------------------------- Done

3. The minting fees is randomly between 40-60% of the desired current amount

4. The base price will be less than 220% of the current price

5. On the sale of NFT 5% of the profit will be transferred to the bank

6. Bank should have a function to distribute a certain desired amount to all the registered user. This function will not be reflected on frontend

7. Whenever user makes a bid on any NFT, the amount he/she has bid will be freezed on his/her account i.e. his/her balance should not go bellow the freeze amount. Same user can have multiple bids.

8. Whenever transfer happens it releases the bid and that amount will be transferred to the seller.

9. If someone else makes a higher bid the freeze will be released to the current user and new user's account will be made a freeze.

10. In the frontend the bid amount can be increased with at least the 5% of current bid. This should be ensured in the frontend first but also on the backend for cross verification once it passes the frontend.



prompt 1
I want these things to be implemented...
1. In the starting the bank should have total supply of 1000000000000 DAMN
2. These functions and properties should be there in the code
    import Debug "mo:base/Debug";
    import Principal "mo:base/Principal";
    import Result "mo:base/Result";
    import Blob "mo:base/Blob";
    import HashMap "mo:base/HashMap";
    import Iter "mo:base/Iter";
    import Nat8 "mo:base/Nat8";
    import Array "mo:base/Array";

    // ICRC-1 Token Canister with dynamic 3% fee, one-time payout, and debugBalances
    actor class ICRC1Token() = this {
      // --- Types ---
      type Timestamp = Nat64;
      type Subaccount = Blob;
      public type Account = { owner: Principal; subaccount: ?Subaccount };
      public type TransferArgs = {
        from_subaccount: ?Subaccount;
        to: Account;
        amount: Nat;
        fee: ?Nat;           // Optional override not supported
        memo: ?Blob;
        created_at_time: ?Timestamp;
      };
      public type TransferError = {
        #BadFee: { expected_fee: Nat };
        #InsufficientFunds: { balance: Nat };
        #GenericError: { error_code: Nat; message: Text };
        #TooOld;
        #CreatedInFuture: { ledger_time: Timestamp };
        #Duplicate: { duplicate_of: Nat };
        #TemporarilyUnavailable;
        #BadBurn: { min_burn_amount: Nat };
      };
      public type Value = {
        #Nat: Nat;
        #Int: Int;
        #Text: Text;
        #Blob: Blob;
      };
      public type Result<Ok, Err> = Result.Result<Ok, Err>;

      // --- Metadata & State ---
      let NAME = "DAMN Token";
      let SYMBOL = "DAMN";
      let DECIMALS: Nat8 = 8;
      let INITIAL_SUPPLY: Nat = 1_000_000_000_000;
      let deployer: Principal = Principal.fromActor(this);

      stable var stableBalances: [((Account, Nat))] = [];
      var balances = HashMap.HashMap<Account, Nat>(
        64,
        func(a, b) = a.owner == b.owner and a.subaccount == b.subaccount,
        func(a) = Principal.hash(a.owner)
      );

      stable var stableClaims: [(Principal, Bool)] = [];
      var claimed = HashMap.HashMap<Principal, Bool>(
        128, Principal.equal, Principal.hash
      );

      // --- Upgrade Hooks ---
      system func preupgrade() {
        stableBalances := Iter.toArray(balances.entries());
        stableClaims := Iter.toArray(claimed.entries());
      };
      system func postupgrade() {
        balances := HashMap.fromIter<Account, Nat>(
          stableBalances.vals(),
          64,
          func(a, b) = a.owner == b.owner and a.subaccount == b.subaccount,
          func(a) = Principal.hash(a.owner)
        );
        claimed := HashMap.HashMap<Principal, Bool>(
          128, Principal.equal, Principal.hash
        );
        let len = Array.size(stableClaims);
        if(len > 0) {
          for (i in Iter.range(0, len - 1)) {
            let (p, b) = stableClaims[i];
            claimed.put(p, b);
          };
        };
      };

      // --- Constructor Mint ---
      balances.put({ owner = deployer; subaccount = null }, INITIAL_SUPPLY);

      // --- ICRC-1 Standard Queries ---
      public shared query func icrc1_name() : async Text { NAME };
      public shared query func icrc1_symbol() : async Text { SYMBOL };
      public shared query func icrc1_decimals() : async Nat8 { DECIMALS };
      public shared query func icrc1_fee() : async Nat { 0 };
      public shared query func icrc1_total_supply() : async Nat {
        var sum: Nat = 0;
        for ((_, bal) in balances.entries()) { sum += bal };
        sum
      };
      public shared query func icrc1_minting_account() : async ?Account {
        ?{ owner = deployer; subaccount = null }
      };
      public shared query func icrc1_balance_of(account: Account) : async Nat {
        switch (balances.get(account)) {
          case null { 0 };
          case (?b) { b };
        }
      };
      public shared query func icrc1_metadata() : async [(Text, Value)] {
        [
          ("icrc1:name", #Text(NAME)),
          ("icrc1:symbol", #Text(SYMBOL)),
          ("icrc1:decimals", #Nat(Nat8.toNat(DECIMALS))),
          ("fee_rate", #Text("3%"))
        ]
      };
      public shared query func icrc1_supported_standards() : async [ { name: Text; url: Text } ] {
        [ { name = "ICRC-1"; url = "https://github.com/dfinity/ICRC-1" } ]
      };

      // --- ICRC-1 Transfer Implementation with 3% fee ---
      public shared(msg) func icrc1_transfer(args: TransferArgs) : async Result<Nat, TransferError> {
        let caller = msg.caller;
        let fromAcct: Account = { owner = caller; subaccount = args.from_subaccount };
        let toAcct = args.to;

        if (fromAcct.owner == toAcct.owner and fromAcct.subaccount == toAcct.subaccount) {
          return #err(#GenericError { error_code = 1; message = "Cannot send to self" });
        };

        let feeAmt: Nat = (args.amount * 3) / 100;
        if (args.fee != null and args.fee != ?feeAmt) {
          return #err(#BadFee { expected_fee = feeAmt });
        };

        let total = args.amount + feeAmt;
        let fromBal = switch (balances.get(fromAcct)) { case null 0; case (?b) b };
        if (fromBal < total) {
          return #err(#InsufficientFunds { balance = fromBal });
        };

        balances.put(fromAcct, fromBal - total);
        let toBal = switch (balances.get(toAcct)) { case null 0; case (?b) b };
        balances.put(toAcct, toBal + args.amount);

        return #ok(0);
      };

      // --- One-time Payout Function ---
      public shared(msg) func payOut() : async Text {
        let caller = msg.caller; 
        if (claimed.get(caller) == ?true) {
          return "Already Claimed";
        };
        let payoutAmount: Nat = 10_000;
        let depAcct: Account = { owner = deployer; subaccount = null };
        let depBal = switch (balances.get(depAcct)) { case null 0; case (?b) b };
        if (depBal < payoutAmount) {
          return "Insufficient funds in treasury";
        };
        balances.put(depAcct, depBal - payoutAmount);
        balances.put({ owner = caller; subaccount = null }, payoutAmount);
        claimed.put(caller, true);
        return "Payout Successful";
      };

      // --- Debug Utility ---
      public shared query func debugBalances() : async [ (Account, Nat) ] {
        Iter.toArray(balances.entries())
      };
  }
3. On the transfer, 3% of the transfer amount should be deducted from the sender
4. We should have the query functions as per the example
5. The account should be created unique to the users like in the referrence


Prompt 2.
In the frontend of the bank make sure that these things are there:- 
1. functions of transfer DAMN is there with showing 3% charge
2. Check the bank balance of the own account only
3. Show the full name of the own account in the navbar and the bank section
4. payout function with initial payout of 10000 DAMN
5. The frontend UI should be modern and inline css should be used extensibly


Prompt 3.
1. Firstly the balance should not be directly displayed on the fronted rather we should have an option to check balance of the user.
2. The payout function is working but the button is not getting dissabled after the first payout or there is no such message like payout already claimed in the frontend.
3. The nav bar is very much old fashioned and the different pages in the frontend have different themes ... redesign the theme and colour combination of the website and also make it look more professional and reliable for the users as it is a nft marketplace and a dbank. Make sure to use the same theme all over the website.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Prompt 4.
//This is dbank/main.mo
import Debug "mo:base/Debug";
import Text "mo:base/Text";
import Principal "mo:base/Principal";
import Result "mo:base/Result";
import Blob "mo:base/Blob";
import HashMap "mo:base/HashMap";
import Iter "mo:base/Iter";
import Nat8 "mo:base/Nat8";
import Array "mo:base/Array";
import Nat64 "mo:base/Nat64";
import Nat "mo:base/Nat";

// ICRC-1 Token Canister with 3% fee, one-time payout, debugBalances,
// and a compatibility icrc1_transfer_from for your marketplace.
actor class ICRC1Token() = this {
  // ---------- Types ----------
  public type Timestamp = Nat64;
  public type Subaccount = Blob;
  public type Account = { owner : Principal; subaccount : ?Subaccount };

  public type TransferArgs = {
    from_subaccount : ?Subaccount;
    to : Account;
    amount : Nat;
    fee : ?Nat;            // Optional override not supported; enforced as 3%
    memo : ?Blob;
    created_at_time : ?Timestamp;
  };

  public type TransferError = {
    #BadFee : { expected_fee : Nat };
    #InsufficientFunds : { balance : Nat };
    #GenericError : { error_code : Nat; message : Text };
    #TooOld;
    #CreatedInFuture : { ledger_time : Timestamp };
    #Duplicate : { duplicate_of : Nat };
    #TemporarilyUnavailable;
    #BadBurn : { min_burn_amount : Nat };
  };

  public type Value = {
    #Nat : Nat;
    #Int : Int;
    #Text : Text;
    #Blob : Blob;
  };

  public type Std = { name : Text; url : Text };
  public type Result<T, E> = Result.Result<T, E>;

  // ---------- Token constants ----------
  let NAME : Text = "DAMN Token";
  let SYMBOL : Text = "DAMN";
  let DECIMALS : Nat8 = 8;
  let INITIAL_SUPPLY : Nat = 1_000_000_000_000;

  // Use the canister itself as the initial treasury/minting account
  let deployer : Principal = Principal.fromActor(this);
  let treasury : Account = { owner = deployer; subaccount = null };

  // ---------- Stable state ----------
  // Store balances and claimed flags across upgrades
  stable var stableBalances : [ (Account, Nat) ] = [];
  stable var stableClaims : [ (Principal, Bool) ] = [];

  // ---------- In-memory state ----------
  // Equality compares both owner and subaccount (unique per user+sub)
  // Hash uses only owner to keep it simple (valid; may cause collisions).
  var balances : HashMap.HashMap<Account, Nat> = HashMap.HashMap<Account, Nat>(
    256,
    func(a : Account, b : Account) : Bool =
      a.owner == b.owner and a.subaccount == b.subaccount,
    // DON'T annotate return type here — let compiler infer from Principal.hash
    func(a : Account) = Principal.hash(a.owner)
  );

  var claimed : HashMap.HashMap<Principal, Bool> =
    HashMap.HashMap<Principal, Bool>(256, Principal.equal, Principal.hash);

  // ---------- Upgrade hooks ----------
  system func preupgrade() {
    stableBalances := Iter.toArray(balances.entries());
    stableClaims := Iter.toArray(claimed.entries());
  };

  system func postupgrade() {
    balances := HashMap.fromIter<Account, Nat>(
      stableBalances.vals(),
      256,
      func(a : Account, b : Account) : Bool =
        a.owner == b.owner and a.subaccount == b.subaccount,
      func(a : Account) = Principal.hash(a.owner)
    );

    claimed := HashMap.HashMap<Principal, Bool>(256, Principal.equal, Principal.hash);
    for ((p, wasClaimed) in stableClaims.vals()) {
      claimed.put(p, wasClaimed);
    };
  };

  // ---------- Constructor mint ----------
  // Mint the full initial supply to the treasury (the canister itself).
  // Executed at install time.
  ignore do {
    let cur = switch (balances.get(treasury)) { case (?b) b; case null 0 };
    balances.put(treasury, cur + INITIAL_SUPPLY);
  };

  // ---------- ICRC-1 queries ----------
  public shared query func icrc1_name() : async Text { NAME };

  public shared query func icrc1_symbol() : async Text { SYMBOL };

  public shared query func icrc1_decimals() : async Nat8 { DECIMALS };

  // We implement dynamic % fee, so the fixed base fee is 0.
  public shared query func icrc1_fee() : async Nat { 0 };

  public shared query func icrc1_total_supply() : async Nat {
    var sum : Nat = 0;
    for ((_, bal) in balances.entries()) { sum += bal };
    sum
  };

  public shared query func icrc1_minting_account() : async ?Account {
    ?treasury
  };

  public shared query func icrc1_balance_of(account : Account) : async Nat {
    switch (balances.get(account)) {
      case (?b) b;
      case null 0;
    }
  };

  public shared query func icrc1_metadata() : async [ (Text, Value) ] {
    [
      ("icrc1:name", #Text(NAME)),
      ("icrc1:symbol", #Text(SYMBOL)),
      ("icrc1:decimals", #Nat(Nat8.toNat(DECIMALS))),
      // Advertise the dynamic percentage fee here:
      ("fee_rate", #Text("3% of transfer amount"))
    ]
  };

  public shared query func icrc1_supported_standards() : async [Std] {
    [ { name = "ICRC-1"; url = "https://github.com/dfinity/ICRC-1" } ]
  };

  // ---------- Core transfer with 3% fee ----------
  public shared(msg) func icrc1_transfer(args : TransferArgs)
    : async Result<Nat, TransferError>
  {
    let fromAcct : Account = { owner = msg.caller; subaccount = args.from_subaccount };
    let toAcct : Account = args.to;

    if (fromAcct.owner == toAcct.owner and fromAcct.subaccount == toAcct.subaccount) {
      return #err(#GenericError { error_code = 1; message = "Cannot send to self" });
    };

    // dynamic 3% fee
    let feeAmt : Nat = (args.amount * 3) / 100;

    // If caller supplied a fee, enforce it equals 3%
    if (args.fee != null and args.fee != ?feeAmt) {
      return #err(#BadFee { expected_fee = feeAmt });
    };

    let total = args.amount + feeAmt;

    let fromBal =
      switch (balances.get(fromAcct)) { case (?b) b; case null 0 };

    if (fromBal < total) {
      return #err(#InsufficientFunds { balance = fromBal });
    };

    // debit sender
    balances.put(fromAcct, fromBal - total);

    // credit receiver with amount (fee is *not* added to receiver)
    let toBal = switch (balances.get(toAcct)) { case (?b) b; case null 0 };
    balances.put(toAcct, toBal + args.amount);

    // credit fee to treasury
    let treasBal = switch (balances.get(treasury)) { case (?b) b; case null 0 };
    balances.put(treasury, treasBal + feeAmt);

    // ICRC-1 returns a block height; we return 0 as a placeholder
    #ok(0)
  };

  // ---------- One-time payout per principal ----------
  public shared(msg) func payOut() : async Text {
    let caller = msg.caller;

    switch (claimed.get(caller)) {
      case (?true) { return "Already Claimed" };
      case _ {};
    };

    let payoutAmount : Nat = 10_000;

    // Pay from treasury
    let treasBal = switch (balances.get(treasury)) { case (?b) b; case null 0 };
    if (treasBal < payoutAmount) {
      return "Insufficient funds in treasury";
    };

    balances.put(treasury, treasBal - payoutAmount);

    let userAcct : Account = { owner = caller; subaccount = null };
    let userBal = switch (balances.get(userAcct)) { case (?b) b; case null 0 };
    balances.put(userAcct, userBal + payoutAmount);

    claimed.put(caller, true);
    "Payout Successful"
  };

  // ---------- Debug utility ----------
  public shared query func debugBalances() : async [ (Account, Nat) ] {
    Iter.toArray(balances.entries())
  };

  // ---------- Compatibility shim for your Marketplace ----------
  // Your Marketplace expects: icrc1_transfer_from(TransferArgs) -> { error : ?Text; height : Nat64 }
  // We implement it by calling icrc1_transfer with msg.caller as "from".
  public shared(msg) func icrc1_transfer_from(args : TransferArgs)
    : async { error : ?Text; height : Nat64 }
  {
    // adapt "to" already an Account; fee logic the same
    let res = await icrc1_transfer(args);
    switch (res) {
      case (#ok(_height)) { return { error = null; height = 0 }; };
      case (#err(e)) {
        let msgText : Text = switch e {
          case (#BadFee { expected_fee }) { "BadFee. expected=" # Nat.toText(expected_fee) };
          case (#InsufficientFunds { balance }) { "InsufficientFunds. balance=" # Nat.toText(balance) };
          case (#GenericError { error_code; message }) {
            "GenericError(" # Nat.toText(error_code) # "): " # message
          };
          case (#TooOld) { "TooOld" };
          case (#CreatedInFuture { ledger_time }) {
            // ledger_time is Nat64; convert to Nat for Nat.toText
            "CreatedInFuture(" # Nat.toText(Nat64.toNat(ledger_time)) # ")"
          };
          case (#Duplicate { duplicate_of }) { "Duplicate(" # Nat.toText(duplicate_of) # ")" };
          case (#TemporarilyUnavailable) { "TemporarilyUnavailable" };
          case (#BadBurn { min_burn_amount }) {
            "BadBurn. min=" # Nat.toText(min_burn_amount)
          };
        };
        { error = ?msgText; height = 0 };
      };
    }
  };
}


//This is marketplace/main.mo
import Nat "mo:base/Nat";
import Nat64 "mo:base/Nat64";
import Text "mo:base/Text";
import Principal "mo:base/Principal";
import HashMap "mo:base/HashMap";
import Option "mo:base/Option";
import Array "mo:base/Array";
import Time "mo:base/Time";
import Hash "mo:base/Hash";
import Debug "mo:base/Debug";
import Iter "mo:base/Iter";

// Marketplace actor class
actor class Marketplace(tokenCid: Principal, nftCid: Principal) = this {

  // -------- ICRC-1 Token Interface --------
  public type TransferArgs = {
    from_subaccount : ?[Nat8];
    to : Principal;
    amount : Nat;
    fee : ?Nat;
    memo : ?[Nat8];
    created_at_time : ?Nat64;
  };
  public type ICRC1 = actor {
    icrc1_transfer_from : (TransferArgs) -> async { error : ?Text; height : Nat64 };
  };

  // ------ Types ------
  public type TokenId = Nat;
  public type Metadata = { uri: Text; name: Text };
  public type NFT = actor {
    icrc7_ownerOf : (TokenId) -> async ?Principal;
    icrc7_approve : (Principal, TokenId) -> async Bool;
    icrc7_transfer : (Principal, TokenId) -> async Bool;
    icrc7_metadata : (TokenId) -> async ?Metadata;
    icrc7_getApproved : (TokenId) -> async ?Principal;
  };
  public type Auction = {
    tokenId       : TokenId;
    nftCid        : Principal;
    owner         : Principal;
    minBid        : Nat;
    highestBid    : Nat;
    highestBidder : ?Principal;
    endTime       : ?Nat64;
    metadata      : Metadata;
  };

  // ------ State ------
  let nft : NFT = actor(Principal.toText(nftCid));
  let token : ICRC1 = actor(Principal.toText(tokenCid));

  // in-memory HashMap for listings
  var listings : HashMap.HashMap<TokenId, Auction> =
    HashMap.HashMap<TokenId, Auction>(32, Nat.equal, Hash.hash);

  // ------ List Auction ------
  public shared(msg) func listForAuction(tokenId: TokenId, minBid: Nat, durationSec: Nat64) : async ?Text {
    let metaOpt = await nft.icrc7_metadata(tokenId);
    switch (metaOpt) {
      case null { return ?"Missing metadata" };
      case (?meta) {
        let ownerOpt = await nft.icrc7_ownerOf(tokenId);
        switch (ownerOpt) {
          case null { return ?"Not NFT owner" };
          case (?owner) { if (owner != msg.caller) { return ?"Not NFT owner" } };
        };
        let approvedOpt = await nft.icrc7_getApproved(tokenId);
        switch (approvedOpt) {
          case null { return ?"Marketplace not approved" };
          case (?approver) {
            if (approver != Principal.fromActor(this)) { return ?"Marketplace not approved" };
          };
        };

        // compute end time as Nat64
        let now64 : Nat64 = Nat64.fromIntWrap(Time.now());
        let addNanos : Nat64 = Nat64.mul(durationSec, Nat64.fromNat(1_000_000_000));
        let endTime64 : Nat64 = Nat64.add(now64, addNanos);

        let auction : Auction = {
          tokenId = tokenId;
          nftCid = nftCid;
          owner = msg.caller;
          minBid = minBid;
          highestBid = 0;
          highestBidder = null;
          endTime = ?endTime64;
          metadata = meta;
        };
        listings.put(tokenId, auction);
        return null;
      };
    };
  };

  // ------ Bid ------
  public shared(msg) func bid(tokenId: TokenId, bidAmt: Nat) : async ?Text {
    switch (listings.get(tokenId)) {
      case null { return ?"Not listed" };
      case (?auction) {
        let now64 : Nat64 = Nat64.fromIntWrap(Time.now());
        let ended = switch (auction.endTime) {
          case null { false };
          case (?end) end < now64;
        };
        if (ended) { return ?"Auction has ended" };

        let minValid =
          if (auction.highestBid == 0)
            auction.minBid
          else
            auction.highestBid + (auction.highestBid * 5) / 100;
        if (bidAmt < minValid) { return ?("Bid < min (" # Nat.toText(minValid) # ")") };

        // --- Payment: transfer bidAmt to escrow (marketplace canister) ---
        let payRes = await token.icrc1_transfer_from({
          from_subaccount = null;
          to = Principal.fromActor(this);
          amount = bidAmt;
          fee = null;
          memo = null;
          created_at_time = null;
        });
        switch (payRes.error) {
          case (?err) { return ?("Payment failed: " # err) };
          case null { /* proceed */ };
        };

        // --- Refund previous highest bidder, if any ---
        switch (auction.highestBidder) {
          case (?prev) {
            if (auction.highestBid > 0) {
              // Attempt refund (ignore failure)
              ignore await token.icrc1_transfer_from({
                from_subaccount = null;
                to = prev;
                amount = auction.highestBid;
                fee = null;
                memo = null;
                created_at_time = null;
              });
            };
          };
          case null { /* nothing to refund */ };
        };

        // --- Update auction record ---
        let updated : Auction = {
          tokenId = auction.tokenId;
          nftCid = auction.nftCid;
          owner = auction.owner;
          minBid = auction.minBid;
          highestBid = bidAmt;
          highestBidder = ?msg.caller;
          endTime = auction.endTime;
          metadata = auction.metadata;
        };
        listings.put(tokenId, updated);
        return null;
      };
    };
  };

  // ------ Settle Auction ------
  public shared(msg) func settleAuction(tokenId: TokenId) : async ?Text {
    switch (listings.get(tokenId)) {
      case null { return ?"No such auction" };
      case (?auction) {
        let now64 : Nat64 = Nat64.fromIntWrap(Time.now());
        switch (auction.endTime) {
          case null { return ?"Auction has no end time" };
          case (?end) { if (now64 < end) { return ?"Auction has not ended yet" } };
        };
        switch (auction.highestBidder) {
          case null { return ?"No winner" };
          case (?winner) {
            // --- Pay seller out of escrow ---
            let paySeller = await token.icrc1_transfer_from({
              from_subaccount = null;
              to = auction.owner;
              amount = auction.highestBid;
              fee = null;
              memo = null;
              created_at_time = null;
            });
            switch (paySeller.error) {
              case (?err) { return ?("Payout failed: " # err) };
              case null { /* proceed */ };
            };
            // --- Transfer NFT to winner ---
            ignore await nft.icrc7_transfer(winner, tokenId);
            // --- Close auction ---
            listings.delete(tokenId);
            return null;
          };
        };
      };
    };
  };

  // ------ Queries ------
  public query func getActiveAuctions() : async [Auction] {
    let now64 : Nat64 = Nat64.fromIntWrap(Time.now());
    let ids = Iter.toArray<TokenId>(listings.keys());
    // Map ids -> auctions (should exist)
    let auctions = Array.map<TokenId, Auction>(ids, func(id: TokenId) : Auction {
      switch (listings.get(id)) {
        case (?a) a;
        case null { Debug.trap("Invariant violated: missing auction for id") };
      }
    });
    // Filter active auctions (no endTime or end > now)
    Array.filter<Auction>(auctions, func(a: Auction) : Bool {
      switch (a.endTime) {
        case null { true };
        case (?end) end > now64;
      }
    })
  };
}


//This is nft/main.mo
import Nat "mo:base/Nat";
import Text "mo:base/Text";
import Principal "mo:base/Principal";
import HashMap "mo:base/HashMap";
import Array "mo:base/Array";
import Option "mo:base/Option";
import Hash "mo:base/Hash";
import Nat32 "mo:base/Nat32";

actor class NFTCanister() = this {

  // --- Types ---
  public type TokenId = Nat;
  public type Metadata = { uri: Text; name: Text };
  public type NFT = { owner: Principal; metadata: Metadata; approved: ?Principal };

  // --- State ---
  
//   transient var tokens : HashMap.HashMap<TokenId, NFT> = HashMap.HashMap<TokenId, NFT>(64, Nat.equal, Nat.hash);
  var tokens : HashMap.HashMap<TokenId, NFT> =
    HashMap.HashMap<TokenId, NFT>(
      64,
      Nat.equal,
      Hash.hash
    );
  stable var nextTokenId: TokenId = 0;
  // --- Mint ---
  public shared(msg) func icrc7_mint(metadata: Metadata) : async TokenId {
    let id = nextTokenId;
    nextTokenId += 1;
    let nft : NFT = { owner = msg.caller; metadata = metadata; approved = null };
    tokens.put(id, nft);
    id
  };

  // --- Transfer (owner or approved) ---
  public shared(msg) func icrc7_transfer(to: Principal, id: TokenId) : async Bool {
    switch (tokens.get(id)) {
      case (?nft) {
        let isOwner = nft.owner == msg.caller;
        let isApproved = switch (nft.approved) {
          case (?p) p == msg.caller;
          case null false;
        };
        if (isOwner or isApproved) {
          let updated : NFT = { owner = to; metadata = nft.metadata; approved = null };
          tokens.put(id, updated);
          return true;
        } else {
          return false;
        }
      };
      case null return false;
    }
  };

  // --- Approve ---
  public shared(msg) func icrc7_approve(operator: Principal, id: TokenId) : async Bool {
    switch (tokens.get(id)) {
      case (?nft) {
        if (nft.owner == msg.caller) {
          let updated : NFT = { owner = nft.owner; metadata = nft.metadata; approved = ?operator };
          tokens.put(id, updated);
          return true;
        } else {
          return false;
        }
      };
      case null return false;
    }
  };

  // --- Revoke ---
  public shared(msg) func icrc7_revoke(id: TokenId) : async Bool {
    switch (tokens.get(id)) {
      case (?nft) {
        if (nft.owner == msg.caller) {
          let updated : NFT = { owner = nft.owner; metadata = nft.metadata; approved = null };
          tokens.put(id, updated);
          return true;
        } else {
          return false;
        }
      };
      case null return false;
    }
  };

  // --- Queries ---

  public query func icrc7_ownerOf(id: TokenId) : async ?Principal {
    switch (tokens.get(id)) {
      case (?nft) ?nft.owner;
      case null null;
    }
  };

  public query func icrc7_getApproved(id: TokenId) : async ?Principal {
    switch (tokens.get(id)) {
      case (?nft) nft.approved;
      case null null;
    }
  };

  public query func icrc7_tokenUri(id: TokenId) : async ?Text {
    switch (tokens.get(id)) {
      case (?nft) ?nft.metadata.uri;
      case null null;
    }
  };

  // Returns all token ids owned by `owner`
  public query func icrc7_tokensOf(owner: Principal) : async [TokenId] {
    let n = nextTokenId;
    let tokensArr = Array.tabulate<TokenId>(n, func(i: Nat): Nat { i });
    Array.filter<TokenId>(tokensArr, func (id) : Bool {
      switch (tokens.get(id)) { case (?nft) nft.owner == owner; case null false }
    })
  };

  public query func icrc7_metadata(id: TokenId) : async ?Metadata {
    switch (tokens.get(id)) {
      case (?nft) ?nft.metadata;
      case null null;
    }
  };
};

Rewrite the marketplace/main.mo with the following logic
1. The minting fees is randomly between 40-60% of the desired current amount

2. The base price of bidding will be less than 220% of the current price

3. On the sale of NFT 5% of the profit will be transferred to the bank

4. Whenever user makes a bid on any NFT, the amount he/she has bid will be freezed on his/her account i.e. his/her balance should not go bellow the freeze amount. Same user can have multiple bids on different nfts.

5. Whenever transfer happens it releases the bid and that amount will be transferred to the seller.

6. If someone else makes a higher bid the freeze will be released to the current user and new user's account will be made a freeze.

7. In the frontend the bid amount can be increased with at least the 5% of current bid. This should be ensured in the frontend first but also on the backend for cross verification once it passes the frontend.


This can require us to change dbank marketplace and nft /main.mo

